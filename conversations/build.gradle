apply plugin: 'com.android.model.library'
apply plugin: 'nebula.provided-base'

def currentToolchainVersion = "4.9"
def twilioSdkHome = "/usr/local/twilio-sdk"
def supportedAbis = [
        "armeabi-v7a",
        // TODO add multi arch support
//        "arm64-v8a",
//        "x86",
//        "x86_64"
]

/**
 * TODO
 * Technically we should be able to support multiple archs once we have all the dependencies
 * built. However, due to limitations in the current NDK support with experimental Android plugin
 * we have to hardlink deps according to this arch variable. If you have other archs you want to
 * compile the SDK for you can, but you have to update this variable first.
 */
def currentArch = "armeabiv7a"

def coreHome = "${twilioSdkHome}/core/android"
/**
 * FIXME
 * This is dumb but we know we support armeabiv7a so we will set the headers directory
 * for each static library to this include directory. The header files should not change
 * across architectures.
 */
def coreHeaders = "${coreHome}/armeabiv7a/include"
def coreStaticLib = "lib/libtwilio-sdk-core-full.a"

def twilioCommonHome = "${twilioSdkHome}/twilio-common/android"
def twilioCommonHeaders = "${twilioCommonHome}/armeabiv7a/include"
def twilioCommonStaticLib = "lib/libtwilio-common.a"

def pocoHome = "${twilioSdkHome}/poco/android"
def pocoHeaders = "${pocoHome}/armeabiv7a/include"
def pocoCryptoHeaders = "${pocoHeaders}/Crypto"
def pocoFoundationStaticLib = "lib/libPocoFoundation.a"
def pocoNetStaticLib = "lib/libPocoNet.a"
def pocoCryptoStaticLib = "lib/libPocoCrypto.a"
def pocoNetSslStaticLib = "lib/libPocoNetSSL.a"
def pocoUtilStaticLib = "lib/libPocoUtil.a"
def pocoXmlStaticLib = "lib/libPocoXML.a"
def pocoJsonStaticLib = "lib/libPocoJSON.a"

def boringSslHome = "${twilioSdkHome}/boringssl/android"
def boringSslHeaders = "${boringSslHome}/armeabiv7a/include"
def boringSslStaticLib = "lib/libboringssl.a"

def webRtcHome = "${twilioSdkHome}/webrtc/android"
def webRtcHeaders = "${webRtcHome}/armeabiv7a/include"
def webRtcStaticLib = "lib/libwebrtc.a"
def webRtcJniStaticLib = "lib/libwebrtc-jni.a"

configurations {
    provided
}

model {
    repositories {
        libs(PrebuiltLibraries) {
            twilioSdkCore {
                headers.srcDir "${coreHeaders}"
                binaries.withType(StaticLibraryBinary) {
                    def coreStaticLibPath = "${coreHome}/" +
                            "${convertAbiToArch(targetPlatform.getName())}/${coreStaticLib}"
                    staticLibraryFile = file("${coreStaticLibPath}")
                }
            }
            twilioCommon {
                headers.srcDir "${twilioCommonHeaders}"
                binaries.withType(StaticLibraryBinary) {
                    def twilioCommonStaticLibPath = "${twilioCommonHome}/" +
                            "${convertAbiToArch(targetPlatform.getName())}/${twilioCommonStaticLib}"
                    staticLibraryFile = file("${twilioCommonStaticLibPath}")
                }
            }
            pocoFoundation {
                headers.srcDir "${pocoHeaders}"
                binaries.withType(StaticLibraryBinary) {
                    def pocoFoundationStaticLibPath = "${pocoHome}/" +
                            "${convertAbiToArch(targetPlatform.getName())}/${pocoFoundationStaticLib}"
                    staticLibraryFile = file("${pocoFoundationStaticLibPath}")
                }
            }
            pocoNet {
                headers.srcDir "${pocoHeaders}"
                binaries.withType(StaticLibraryBinary) {
                    def pocoNetStaticLibPath = "${pocoHome}/" +
                            "${convertAbiToArch(targetPlatform.getName())}/${pocoNetStaticLib}"
                    staticLibraryFile = file("${pocoNetStaticLibPath}")
                }
            }
            pocoCrypto {
                headers.srcDir "${pocoCryptoHeaders}"
                binaries.withType(StaticLibraryBinary) {
                    def pocoCryptoStaticLibPath = "${pocoHome}/" +
                            "${convertAbiToArch(targetPlatform.getName())}/${pocoCryptoStaticLib}"
                    staticLibraryFile = file("${pocoCryptoStaticLibPath}")
                }
            }
            pocoNetSsl {
                headers.srcDir "${pocoHeaders}"
                binaries.withType(StaticLibraryBinary) {
                    def pocoNetSslStaticLibPath = "${pocoHome}/" +
                            "${convertAbiToArch(targetPlatform.getName())}/${pocoNetSslStaticLib}"
                    staticLibraryFile = file("${pocoNetSslStaticLibPath}")
                }
            }
            pocoUtil {
                headers.srcDir "${pocoHeaders}"
                binaries.withType(StaticLibraryBinary) {
                    def pocoUtilStaticLibPath = "${pocoHome}/" +
                            "${convertAbiToArch(targetPlatform.getName())}/${pocoUtilStaticLib}"
                    staticLibraryFile = file("${pocoUtilStaticLibPath}")
                }
            }
            pocoXml {
                headers.srcDir "${pocoHeaders}"
                binaries.withType(StaticLibraryBinary) {
                    def pocoXmlStaticLibPath = "${pocoHome}/" +
                            "${convertAbiToArch(targetPlatform.getName())}/${pocoXmlStaticLib}"
                    staticLibraryFile = file("${pocoXmlStaticLibPath}")
                }
            }
            pocoJson {
                headers.srcDir "${pocoHeaders}"
                binaries.withType(StaticLibraryBinary) {
                    def pocoJsonStaticLibPath = "${pocoHome}/" +
                            "${convertAbiToArch(targetPlatform.getName())}/${pocoJsonStaticLib}"
                    staticLibraryFile = file("${pocoJsonStaticLibPath}")
                }
            }
            boringssl {
                headers.srcDir "${boringSslHeaders}"
                binaries.withType(StaticLibraryBinary) {
                    def boringSslStaticLibPath = "${boringSslHome}/" +
                            "${convertAbiToArch(targetPlatform.getName())}/${boringSslStaticLib}"
                    staticLibraryFile = file("${boringSslStaticLibPath}")
                }
            }
            webrtc {
                headers.srcDir "${webRtcHeaders}"
                binaries.withType(StaticLibraryBinary) {
                    def webRtcStaticLibPath = "${webRtcHome}/" +
                            "${convertAbiToArch(targetPlatform.getName())}/${webRtcStaticLib}"
                    staticLibraryFile = file("${webRtcStaticLibPath}")
                }
            }
        }
    }

    android {
        compileSdkVersion 23
        buildToolsVersion "23.0.2"

        defaultConfig.with {
            minSdkVersion.apiLevel 16
            targetSdkVersion.apiLevel 23
            versionName generateVersionName()
            versionCode generateVersionCode()

            testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
        }
    }

    android.ndk {
        moduleName "jingle_peerconnection_so"
        toolchainVersion "${currentToolchainVersion}"
        platformVersion 16
        stl "c++_static"
        cppFlags.addAll([
                "-DWEBRTC_POSIX",
                "-DTWILIO_SDK_2_0",
                "-DWEBRTC_ANDROID",
                "-DWEBRTC_ANDROID_OPENSLES",
                "-DPOCO_ANDROID",
                "-DPJ_IS_BIG_ENDIAN=0",
                "-DPJ_IS_LITTLE_ENDIAN=1",
                "-Wall",
                "-std=gnu++11",
                "-fexceptions"
        ])
        ldLibs.addAll([
                "log",
                "z",
                "m",
                "dl",
                "GLESv2",
                "jnigraphics",
                "OpenSLES",
                "EGL",
                "GLESv1_CM",
                "android",
                // FIXME need to set this according to correct architecture!!
                "${pocoHome}/${currentArch}/${pocoFoundationStaticLib}".toString(),
                "${pocoHome}/${currentArch}/${pocoCryptoStaticLib}".toString()
        ])

        /**
         * Several webrtc classes use native webrtc-jni objects that are only
         * called from Java classes. The compiler will incorrectly strip some
         * of these native webrtc-jni objects during linking because it believes
         * they are unused by the native library. Here we tell the linker to keep
         * the whole archive to prevent this stripping and then we specify in the
         * dependency after we are not using whole archive anymore because the linker
         * applies this option to every library after the option is specified.
         */
        // FIXME need to set this according to correct architecture!!
        ldFlags.add("-Wl," +
                "--whole-archive," +
                "-l${webRtcHome}/${currentArch}/${webRtcJniStaticLib},".toString() +
                "--no-whole-archive".toString()
        )

        abiFilters.addAll(supportedAbis)
    }

    android.sources {
        main {
            jni {
                exportedHeaders {
                    srcDir "src/main/jni"
                }
                dependencies {
                    library "twilioSdkCore" linkage "static"
                    library "twilioCommon" linkage "static"
                    library "pocoFoundation" linkage "static"
                    library "pocoNet" linkage "static"
                    library "pocoCrypto" linkage "static"
                    library "pocoNetSsl" linkage "static"
                    library "pocoUtil" linkage "static"
                    library "pocoXml" linkage "static"
                    library "pocoJson" linkage "static"
                    library "boringssl" linkage "static"
                    library "webrtc" linkage "static"
                }
            }
        }
    }

    android.buildTypes {
        debug {
            ndk {
                debuggable true
            }
        }
        release {
            minifyEnabled false
        }
    }

    tasks {
        /**
         * Here we create a javadoc tasks that depeonds on the
         * the current android model configuration
         */
        createJavadocs(Javadoc) {
            def androidConfig = $.android

            source = androidConfig.sources.main.java.source
            classpath += project.files("${getSdkDir()}/platforms/${androidConfig.compileSdkVersion}/android.jar");
            options.links("http://docs.oracle.com/javase/7/docs/api/");
            options.links("http://d.android.com/reference/");
            exclude '**/BuildConfig.java'
            exclude '**/R.java'
        }
    }
}

dependencies {
    testCompile 'junit:junit:4.12'
    testCompile 'org.mockito:mockito-core:1.10.19'

    androidTestCompile 'com.squareup.retrofit:retrofit:1.9.0'
    androidTestCompile 'com.android.support:support-annotations:23.1.1'
    androidTestCompile 'com.android.support.test:runner:0.4'
    androidTestCompile 'com.android.support.test:rules:0.4'

    // TODO this jar does not need to be behind an arch directory structure
    compile files("${twilioSdkHome}/webrtc/android/armeabiv7a/lib/libjingle_peerconnection_java.jar")
    provided 'com.twilio.sdk:twilio-common-android:0.2.0'
}

/**
 * Will unzip release aar so we can transform accordingly
 */
task unpackReleaseAar(type: Copy, dependsOn: 'assembleRelease') {
    def aarFile = file("${buildDir}/outputs/aar/conversations-release.aar")
    def outputDir = file("${buildDir}/unpacked/conversations")

    from zipTree(aarFile)
    into outputDir
}

/**
 * Dives into the unpacked aar and creates a directory structure for a fat jar
 */
task prepareReleaseJar(type: Copy, dependsOn: 'unpackReleaseAar') {
    def classesJar = file("${buildDir}/unpacked/conversations/classes.jar")
    def libjingleJar = file("${buildDir}/unpacked/conversations/libs/libjingle_peerconnection_java.jar")
    def jniLibs = file("${buildDir}/unpacked/conversations/jni")
    def jarHome = file("${buildDir}/intermediates/jar")

    from zipTree(classesJar)
    include '**/*.class'
    include '**/*.java'

    from zipTree(libjingleJar)
    include '**/*.class'
    include '**/*.java'

    into jarHome
    into('lib') {
        from fileTree(jniLibs)
        include '**/*.so'
    }
}

/**
 * Creates jar from from release jar intermediate directory
 */
task createReleaseJar(type: Jar, dependsOn: 'prepareReleaseJar') {
    def jarHome = file("${buildDir}/intermediates/jar")

    archiveName = "twilio-conversations-android.jar"
    destinationDir = file("${buildDir}/outputs/jar")
    from jarHome
}

/**
 * Aggragates the quickstart app, javadoc, and release jar into
 * intermediate directory for packaging. Note that the jars will be suffixed with
 * the current version
 */
task prepareReleaseTarBz2(type: Copy, dependsOn: 'createReleaseJar') {
    def quickstart = file("../quickstart")
    def javadocHome = file("${buildDir}/docs/javadoc")
    def jarHome = file("${buildDir}/outputs/jar/twilio-conversations-android.jar")
    def tarHome = file("${buildDir}/intermediates/tar")

    into tarHome
    into('javadoc') {
        from javadocHome
    }
    into('quickstart') {
        from quickstart
    }
    into('quickstart/app/libs') {
        from jarHome
        rename { String fileName ->
            fileName.replace('twilio-conversations-android.jar',
                    "twilio-conversations-android-${getVersionName()}.jar")
        }
    }
    into('libs') {
        from jarHome
        rename { String fileName ->
            fileName.replace('twilio-conversations-android.jar',
                    "twilio-conversations-android-${getVersionName()}.jar")
        }
    }
}

/**
 * Creates the tarbz2 file from the intermediate directory
 */
task createReleaseTarBz2(type: Tar, dependsOn: 'prepareReleaseTarBz2') {
    from fileTree(file("${buildDir}/intermediates/tar"))
    baseName = 'twilio-conversations-android'
    destinationDir = file("${buildDir}/outputs/tar")
    extension = 'tar.bz2'
    compression = Compression.BZIP2
}

/**
 * Generates the current javadocs, assembles the project as release, and packages
 * artifacts into tar
 */
task packageRelease(type: GradleBuild){
    tasks = ['createJavadocs', 'createReleaseTarBz2']
}

/**
 * Localize the JNI_OnLoad and JNI_OnUnLoad symbol in libwebrtc-jni.a to prevent conflicts with
 * initialization
 */
task localizeWebRtcJniLoadUnLoad(type: Exec, dependsOn: assemble) {
    def webRtcHomeNoArch = "${twilioSdkHome}/webrtc/android"
    def ndkDir = getNdkDir()
    def ndkToolchains = "${ndkDir}/toolchains"
    def toolchainMap = [
            "arm-linux-androideabi" : "arm-linux-androideabi",
            "aarch64-linux-android" : "aarch64-linux-android",
            "x86" : "i686-linux-android",
            "x86_64" : "x86_64-linux-android"
    ]
    def supportedArchs = [
            "armeabiv7a" : "arm-linux-androideabi",
            "arm64v8a" : "aarch64-linux-android",
            "x86" : "i686-linux-android",
            "x86_64" : "x86_64-linux-android"
    ]
    def supportedHosts = [
            "darwin",
            "linux"
    ]
    toolchainMap.each{ toolchainPrefix, toolChainPrebuiltPrefix ->
        supportedArchs.each { arch, archToolChain ->
            supportedHosts.each{ host ->
                def objCopy = "${ndkToolchains}/${toolchainPrefix}-${currentToolchainVersion}" +
                        "/prebuilt/${host}-x86_64/bin/${toolChainPrebuiltPrefix}-objcopy"
                def libWebRtcStaticLib = "${webRtcHomeNoArch}/${arch}/lib/libwebrtc-jni.a"

                if (file("${objCopy}").exists() &&
                        file("${libWebRtcStaticLib}").exists() &&
                        archToolChain == toolChainPrebuiltPrefix) {
                    exec {
                        executable "${objCopy}"
                        args '--localize-symbol',
                                'JNI_OnLoad',
                                "${libWebRtcStaticLib}"
                    }
                    exec {
                        executable "${objCopy}"
                        args '--localize-symbol',
                                'JNI_OnUnLoad',
                                "${libWebRtcStaticLib}"
                    }
                }
            }
        }
    }
}

/**
 * This looks strange but the archs built by our build scripts do not support
 * dashes ('-') so when we build they are removed. Here we just convert the target
 * abi to conform to our standard
 *
 * @param abi Normal android abi
 * @return Twilio version of android abi without dashes ('-')
 */
def convertAbiToArch(abi) {
    return abi.replaceAll("-", "")
}

def getSdkDir() {
    // Checking environment variable for sdk home first
    def sdkHome = System.env.ANDROID_SDK_HOME

    // Android Studio does not see this environment but will generate a
    // local.properties file with the ndk path set
    if (sdkHome == null) {
        println "Could not locate NDK home in environment variable. Trying local.properties"
        Properties properties = new Properties()
        properties.load(project.rootProject.file('local.properties').newDataInputStream())
        sdkHome = properties.getProperty('sdk.dir')
    }

    // Fail the build for not ndk detected
    assert sdkHome != null : "Could not find Android SDK!"

    return sdkHome
}

def getNdkDir() {
    // Checking environment variable for ndk home first
    def ndkHome = System.env.ANDROID_NDK_HOME

    // Android Studio does not see this environment but will generate a
    // local.properties file with the ndk path set
    if (ndkHome == null) {
        println "Could not locate NDK home in environment variable. Trying local.properties"
        Properties properties = new Properties()
        properties.load(project.rootProject.file('local.properties').newDataInputStream())
        ndkHome = properties.getProperty('ndk.dir')
    }

    // Fail the build for not ndk detected
    assert ndkHome != null : "Could not find Android NDK!"

    return ndkHome
}
