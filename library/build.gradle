apply plugin: 'com.android.library'
apply plugin: 'maven'

def currentToolchainVersion = "4.9"
// TODO add back ability for local builds
def coreHome = "${buildDir}/prebuilt/twilio-video"
def compilerVersion = "gnu-4.9"

configurations {
    preCompile
}

android {
    compileSdkVersion 24
    buildToolsVersion "24.0.2"

    // Parameterizing config allows video application to use a debug build of the library
    defaultPublishConfig getPublishConfig()

    defaultConfig {
        minSdkVersion 16
        targetSdkVersion 24

        versionName generateVersionName()
        versionCode generateVersionCode()

        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"

        buildConfigField "String", "ENVIRONMENT", "\"${getEnvironment()}\""
        buildConfigField "String", "TOPOLOGY", "\"${getTopology()}\""

        ndk {
            abiFilters 'x86', 'x86_64', 'armeabi-v7a', 'arm64-v8a'
        }

        externalNativeBuild {
            cmake {
                arguments '-DANDROID_TOOLCHAIN=gcc',
                        '-DANDROID_PLATFORM=android-21',
                        '-DANDROID_STL=c++_static',
                        "-DVIDEO_DEPS_PREFIX=${buildDir}/prebuilt/twilio-video".toString()
                cppFlags "-DWEBRTC_POSIX",
                        /*
                         * Needed to extend cricket::VideoCapturer without causing unwarranted
                         * destructor crashes.
                         */
                        "-DNDEBUG",
                        "-DWEBRTC_BUILD_LIBEVENT",
                        "-DTWILIO_SDK_2_0",
                        "-DWEBRTC_ANDROID",
                        "-DWEBRTC_ANDROID_OPENSLES",
                        "-DPOCO_ANDROID",
                        "-Wall",
                        "-std=c++11",
                        "-fexceptions"
            }
        }
    }

    buildTypes {
        release {
            externalNativeBuild {
                cmake {
                    cppFlags '-Os',
                            '-fomit-frame-pointer',
                            '-fvisibility=hidden'
                }
            }
        }
        debug {
            externalNativeBuild {
                cmake {
                    cppFlags '-g'
                }
            }
        }
    }

    externalNativeBuild {
        cmake {
            path "CMakeLists.txt"
        }
    }
}

dependencies {
    preCompile 'com.twilio.sdk:twilio-video:0.5.0-rc5:android@tar.bz2'

    testCompile 'junit:junit:4.12'
    testCompile 'org.mockito:mockito-core:1.10.19'
    testCompile 'com.google.guava:guava:19.0'

    androidTestCompile project(':env')
    androidTestCompile 'com.squareup.retrofit:retrofit:1.9.0'
    androidTestCompile 'com.android.support.test.espresso:espresso-core:2.2.2'
    androidTestCompile 'com.android.support.test:runner:0.5'
    androidTestCompile 'com.android.support.test:rules:0.5'
    androidTestCompile 'com.android.support.test.uiautomator:uiautomator-v18:2.1.2'
    androidTestCompile 'com.google.code.gson:gson:2.6.2'

    compile 'com.android.support:support-annotations:24.2.1'
    compile 'com.getkeepsafe.relinker:relinker:1.2.2'
    // TODO this really should be on nexus as a jar and not local
    // TODO we are hardcoding architecture for now,
    // because I don't know how to access that information from here
    compile files("${coreHome}/armeabiv7a/gnu-4.9/release/lib/" +
            "libjingle_peerconnection_java.jar")
}

task createJavadocs(type: Javadoc) {
    source android.sourceSets.main.java.srcDirs
    classpath += project.files(android.getBootClasspath().join(File.pathSeparator))
    options {
        title = "Video Android"
        links "https://docs.oracle.com/javase/7/docs/api/"
        linksOffline "https://developer.android.com/reference/",
                "${project.android.sdkDirectory}/docs/reference"
    }
    failOnError false
    exclude '**/BuildConfig.java'
    exclude '**/R.java'
}

/*
 * Iterates over conversations dependencies and ensures they are downloaded
 */
task unpackPrebuilts(type: Copy) {
    def target = file("${buildDir}/prebuilt")

    onlyIf { !target.exists() }

    configurations.preCompile.each { dependency ->
        from tarTree(dependency)
        into target
    }
}

/*
 * Maven upload configuration that can be used for any maven repo
 */
uploadArchives {
    repositories {
        mavenDeployer {
            repository(url: "${mavenRepo}") {
                authentication(
                        userName: mavenUsername,
                        password: mavenPassword
                )
            }
            pom.version = generateVersionName()
            pom.groupId = 'com.twilio'
            pom.artifactId = 'video-android'
            pom.packaging = 'aar'
        }
    }
}

/*
 * Localize the JNI_OnLoad and JNI_OnUnLoad symbol in libwebrtc-jni.a to prevent conflicts with
 * initialization
 */
task localizeWebRtcJniLoadUnLoad(type: Exec, dependsOn: 'unpackPrebuilts') {
    def ndkDir = getNdkDir()
    def ndkToolchains = "${ndkDir}/toolchains"
    def toolchainMap = [
            "arm-linux-androideabi" : "arm-linux-androideabi",
            "aarch64-linux-android" : "aarch64-linux-android",
            "x86" : "i686-linux-android",
            "x86_64" : "x86_64-linux-android"
    ]
    def supportedArchs = [
            "armeabi-v7a" : "arm-linux-androideabi",
            "arm64-v8a" : "aarch64-linux-android",
            "x86" : "i686-linux-android",
            "x86_64" : "x86_64-linux-android"
    ]
    def supportedHosts = [
            "darwin",
            "linux"
    ]

    /*
     * For some reason I have to have something set for command line in order for this task to not
     * complain just ignore this the real work follows in the loops below
     */
    commandLine 'true'
    doLast {
        toolchainMap.each { toolchainPrefix, toolChainPrebuiltPrefix ->
            supportedArchs.each { arch, archToolChain ->
                supportedHosts.each { host ->
                    def objCopy = "${ndkToolchains}/${toolchainPrefix}-${currentToolchainVersion}" +
                            "/prebuilt/${host}-x86_64/bin/${toolChainPrebuiltPrefix}-objcopy"
                    def libWebRtcStaticLib = "${coreHome}/${arch}/${compilerVersion}" +
                            "/release/lib/libwebrtc-jni.a"
                    def libWebRtcDebugStaticLib = "${coreHome}/${arch}/${compilerVersion}" +
                            "/debug/lib/libwebrtc-jni.a"
                    if (file("${objCopy}").exists() &&
                            file("${libWebRtcStaticLib}").exists() &&
                            archToolChain == toolChainPrebuiltPrefix) {
                        exec {
                            executable "${objCopy}"
                            args '--localize-symbol',
                                    'JNI_OnLoad',
                                    "${libWebRtcStaticLib}"
                        }
                        exec {
                            executable "${objCopy}"
                            args '--localize-symbol',
                                    'JNI_OnUnLoad',
                                    "${libWebRtcStaticLib}"
                        }
                    }
                    if (file("${objCopy}").exists() &&
                            file("${libWebRtcDebugStaticLib}").exists() &&
                            archToolChain == toolChainPrebuiltPrefix) {
                        exec {
                            executable "${objCopy}"
                            args '--localize-symbol',
                                    'JNI_OnLoad',
                                    "${libWebRtcDebugStaticLib}"
                        }
                        exec {
                            executable "${objCopy}"
                            args '--localize-symbol',
                                    'JNI_OnUnLoad',
                                    "${libWebRtcDebugStaticLib}"
                        }
                    }
                }
            }
        }
    }
}

// Ensure that our pre build tasks are executed
afterEvaluate {
    android.libraryVariants.all { variant ->
        variant.javaCompiler.dependsOn(localizeWebRtcJniLoadUnLoad)
    }
}

def getNdkDir() {
    // Checking environment variable for ndk home first
    def ndkHome = System.env.ANDROID_NDK_HOME

    /*
     * Android Studio does not see this environment but will generate a local.properties file with
     * the ndk path set
     */
    if (ndkHome == null) {
        println "Could not locate NDK home in environment variable. Trying local.properties"
        Properties properties = new Properties()
        if (project.rootProject.file('local.properties').exists()) {
            properties.load(project.rootProject.file('local.properties').newDataInputStream())
            ndkHome = properties.getProperty('ndk.dir')
        }
    }

    // Fail the build for no ndk detected
    assert ndkHome != null : "Could not find Android NDK!"

    return ndkHome
}

def getEnvironment() {
    // Possible values for ENVIRONMENT are 'prod', 'stage', and 'dev'.

    // Attempt to get it from the environment variable
    def environment = System.getenv("ENVIRONMENT");

    if (environment == null) {
        println "Could not locate ENVIRONMENT environment variable. Trying local.properties"
        Properties properties = new Properties()
        if (project.rootProject.file('local.properties').exists()) {
            properties.load(project.rootProject.file('local.properties').newDataInputStream())
            environment = properties.getProperty('ENVIRONMENT')
        }
    }

    if (environment == null) {
        println "Could not locate ENVIRONMENT in local.properties."
        environment = "prod"
    }

    println "Environment: " + environment
    return environment;
}

def getTopology() {
    // Possible values for VIDEO_TOPOLOGY are 'P2P' and 'SFU'.

    // Attempt to get it from the environment variable
    def topology = System.getenv("VIDEO_TOPOLOGY");

    if (topology == null) {
        println "Could not locate VIDEO_TOPOLOGY environment variable. Trying local.properties"
        Properties properties = new Properties()
        if (project.rootProject.file('local.properties').exists()) {
            properties.load(project.rootProject.file('local.properties').newDataInputStream())
            topology = properties.getProperty('VIDEO_TOPOLOGY')
        }
    }

    if (topology == null) {
        println "Could not locate VIDEO_TOPOLOGY in local.properties."
        topology = "P2P"
    }

    println "Topology: " + topology
    return topology;
}

def getPublishConfig() {
    // Possible values for PUBLISH_CONFIG are 'debug' and 'release'.

    // Attempt to get it from the environment variable
    def publishConfig = System.getenv("PUBLISH_CONFIG");

    if (publishConfig == null) {
        println "Could not locate PUBLISH_CONFIG environment variable. Trying local.properties"
        Properties properties = new Properties()
        if (project.rootProject.file('local.properties').exists()) {
            properties.load(project.rootProject.file('local.properties').newDataInputStream())
            publishConfig = properties.getProperty('PUBLISH_CONFIG')
        }
    }

    if (publishConfig == null) {
        println "Could not locate PUBLISH_CONFIG in local.properties."
        publishConfig = "release"
    }

    println "Publish Config: " + publishConfig
    return publishConfig;
}
