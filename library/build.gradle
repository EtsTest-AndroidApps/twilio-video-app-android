apply plugin: 'com.android.library'
apply plugin: 'maven'
apply plugin: 'jacoco'

def currentToolchainVersion = "4.9"
// TODO add back ability for local builds
def coreHome = "${buildDir}/prebuilt/twilio-video"
def compilerVersion = "gnu-4.9"

configurations {
    preCompile
}

android {
    compileSdkVersion 26
    buildToolsVersion "26.0.2"

    // Parameterizing config allows video application to use a debug build of the library
    defaultPublishConfig getPublishConfig()

    packagingOptions {
        exclude 'META-INF/LICENSE'
    }

    defaultConfig {
        minSdkVersion 16
        targetSdkVersion 26

        versionName generateVersionName()
        versionCode generateVersionCode()

        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"

        ndk {
            abiFilters 'x86', 'x86_64', 'armeabi-v7a', 'arm64-v8a'
        }

        externalNativeBuild {
            cmake {
                // Using android-16 to prevent load libary bug GSDK-1020
                arguments '-DANDROID_TOOLCHAIN=gcc',
                        '-DANDROID_PLATFORM=android-16',
                        '-DANDROID_STL=c++_static',
                        "-DVIDEO_DEPS_PREFIX=${coreHome}".toString()
                cppFlags "-DWEBRTC_POSIX",
                        /*
                         * Needed to extend cricket::VideoCapturer without causing unwarranted
                         * destructor crashes.
                         */
                        "-DNDEBUG",
                        "-DWEBRTC_BUILD_LIBEVENT",
                        "-DTWILIO_SDK_2_0",
                        "-DWEBRTC_ANDROID",
                        "-DWEBRTC_ANDROID_OPENSLES",
                        "-DPOCO_ANDROID",
                        "-Werror",
                        "-Wall",
                        "-std=gnu++11",
                        "-fexceptions",
                        "-Wl,--allow-multiple-definition"
            }
        }
    }

    buildTypes {
        release {
            externalNativeBuild {
                cmake {
                    cppFlags '-Os',
                            '-fomit-frame-pointer',
                            '-fvisibility=hidden'
                }
            }
        }
        debug {
            testCoverageEnabled getTestCoverageEnabled()
            externalNativeBuild {
                cmake {
                    cppFlags '-g'
                }
            }
        }
    }

    externalNativeBuild {
        cmake {
            path "CMakeLists.txt"
        }
    }

    /*
     * Only set BuildConfig for tests so we do not expose the credentials used for tests in our
     * published artifacts
     */
    testVariants.all { testVariant ->
        testVariant.buildConfigField("String", "ENVIRONMENT", "\"${getEnvironment()}\"")
        testVariant.buildConfigField("java.util.Map<String, String>",
            "twilioCredentials",
            "${getTwilioVideoConfig()}")
    }
}

android.testOptions.unitTests.all {
    ignoreFailures false

    jacoco {
        includeNoLocationClasses = true
    }

    testLogging {
        events "passed", "skipped", "failed", "standardOut", "standardError"
    }
}

dependencies {
    preCompile 'com.twilio.sdk:twilio-video:2.0.0-preview5:android@tar.bz2'

    testImplementation 'junit:junit:4.12'
    testImplementation 'org.mockito:mockito-core:1.10.19'
    testImplementation 'com.google.guava:guava:20.0'
    testImplementation 'pl.pragmatists:JUnitParams:1.1.0'

    androidTestImplementation project(':env')
    androidTestImplementation project(':twilioapi')
    androidTestImplementation project(':token')
    androidTestImplementation 'com.squareup.retrofit:retrofit:1.9.0'
    androidTestImplementation 'com.android.support:design:26.1.0'
    androidTestImplementation 'com.android.support:recyclerview-v7:26.1.0'
    androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.0'
    androidTestImplementation 'com.android.support.test.espresso:espresso-contrib:3.0.0'
    androidTestImplementation 'com.android.support.test:runner:1.0.0'
    androidTestImplementation 'com.android.support.test:rules:1.0.0'
    androidTestImplementation 'com.android.support.test.uiautomator:uiautomator-v18:2.1.2'
    androidTestImplementation 'com.google.code.gson:gson:2.7'
    androidTestImplementation 'org.apache.commons:commons-lang3:3.6'

    implementation 'com.android.support:support-annotations:26.1.0'
    implementation 'com.getkeepsafe.relinker:relinker:1.2.2'
    // TODO this really should be on nexus as a jar and not local
    // TODO we are hardcoding architecture for now,
    // because I don't know how to access that information from here
    api files("${coreHome}/armeabi-v7a/gnu-4.9/release/lib/" +
            "libjingle_peerconnection_java.jar")
}

task jacocoTestReport(type: JacocoReport,
        dependsOn: ['testDebugUnitTest', 'createDebugCoverageReport']) {
    reports {
        xml.enabled = true
        html.enabled = true
    }

    def fileFilter = ['**/R.class',
                      '**/R$*.class',
                      '**/BuildConfig.*',
                      '**/Preconditions.*',
                      '**/Manifest*.*',
                      '**/*Test*.*',
                      'android/**/*.*']
    def debugTree = fileTree(dir: "$project.buildDir/intermediates/classes/debug",
            excludes: fileFilter)
    def mainSrc = "$project.projectDir/src/main/java"

    sourceDirectories = files([mainSrc])
    classDirectories = files([debugTree])
    executionData = fileTree(dir: project.buildDir, includes: [
            'jacoco/testDebugUnitTest.exec', 'outputs/code-coverage/connected/*.ec'
    ])
}

task createJavadocs(type: Javadoc) {
    source android.sourceSets.main.java.srcDirs
    classpath += project.files(android.getBootClasspath().join(File.pathSeparator))
    options {
        title = "Video Android"
        links "https://docs.oracle.com/javase/7/docs/api/"
        linksOffline "https://developer.android.com/reference/",
                "${project.android.sdkDirectory}/docs/reference"
    }
    failOnError false
    exclude '**/BuildConfig.java'
    exclude '**/R.java'
}

/*
 * Iterates over conversations dependencies and ensures they are downloaded
 */
task unpackPrebuilts(type: Copy) {
    def target = file("${buildDir}/prebuilt")

    onlyIf { !target.exists() }

    configurations.preCompile.each { dependency ->
        from tarTree(dependency)
        into target
    }
}

/*
 * Maven upload configuration that can be used for any maven repo
 */
uploadArchives {
    repositories {
        mavenDeployer {
            repository(url: "${mavenRepo}") {
                authentication(
                        userName: mavenUsername,
                        password: mavenPassword
                )
            }
            pom.version = generateVersionName()
            pom.groupId = 'com.twilio'
            pom.artifactId = 'video-android'
            pom.packaging = 'aar'
        }
    }
}

task androidJavadocsJar(type: Jar, dependsOn: createJavadocs) {
    classifier = 'javadoc'
    from createJavadocs.destinationDir
}

task androidSourcesJar(type: Jar) {
    classifier = 'sources'
    from android.sourceSets.main.java.source
}

artifacts {
    archives androidSourcesJar
    archives androidJavadocsJar
}

/*
 * Localize the JNI_OnLoad and JNI_OnUnLoad symbol in libwebrtc-jni.a to prevent conflicts with
 * initialization
 */
task localizeWebRtcJniLoadUnLoad(type: Exec, dependsOn: 'unpackPrebuilts') {
    def ndkDir = getNdkDir()
    def ndkToolchains = "${ndkDir}/toolchains"
    def toolchainMap = [
            "arm-linux-androideabi" : "arm-linux-androideabi",
            "aarch64-linux-android" : "aarch64-linux-android",
            "x86" : "i686-linux-android",
            "x86_64" : "x86_64-linux-android"
    ]
    def supportedArchs = [
            "armeabi-v7a" : "arm-linux-androideabi",
            "arm64-v8a" : "aarch64-linux-android",
            "x86" : "i686-linux-android",
            "x86_64" : "x86_64-linux-android"
    ]
    def supportedHosts = [
            "darwin",
            "linux"
    ]

    /*
     * For some reason I have to have something set for command line in order for this task to not
     * complain just ignore this the real work follows in the loops below
     */
    commandLine 'true'
    doLast {
        toolchainMap.each { toolchainPrefix, toolChainPrebuiltPrefix ->
            supportedArchs.each { arch, archToolChain ->
                supportedHosts.each { host ->
                    def objCopy = "${ndkToolchains}/${toolchainPrefix}-${currentToolchainVersion}" +
                            "/prebuilt/${host}-x86_64/bin/${toolChainPrebuiltPrefix}-objcopy"
                    def libWebRtcStaticLib = "${coreHome}/${arch}/${compilerVersion}" +
                            "/release/lib/libwebrtc-jni.a"
                    def libWebRtcDebugStaticLib = "${coreHome}/${arch}/${compilerVersion}" +
                            "/debug/lib/libwebrtc-jni.a"
                    if (file("${objCopy}").exists() &&
                            file("${libWebRtcStaticLib}").exists() &&
                            archToolChain == toolChainPrebuiltPrefix) {
                        exec {
                            executable "${objCopy}"
                            args '--localize-symbol',
                                    'JNI_OnLoad',
                                    "${libWebRtcStaticLib}"
                        }
                        exec {
                            executable "${objCopy}"
                            args '--localize-symbol',
                                    'JNI_OnUnLoad',
                                    "${libWebRtcStaticLib}"
                        }
                    }
                    if (file("${objCopy}").exists() &&
                            file("${libWebRtcDebugStaticLib}").exists() &&
                            archToolChain == toolChainPrebuiltPrefix) {
                        exec {
                            executable "${objCopy}"
                            args '--localize-symbol',
                                    'JNI_OnLoad',
                                    "${libWebRtcDebugStaticLib}"
                        }
                        exec {
                            executable "${objCopy}"
                            args '--localize-symbol',
                                    'JNI_OnUnLoad',
                                    "${libWebRtcDebugStaticLib}"
                        }
                    }
                }
            }
        }
    }
}

// Ensure that our pre build tasks are executed
afterEvaluate {
    android.libraryVariants.all { variant ->
        variant.preBuild.dependsOn(localizeWebRtcJniLoadUnLoad)
    }
}

def getNdkDir() {
    // Checking environment variable for ndk home first
    def ndkHome = System.env.ANDROID_NDK_HOME

    /*
     * Android Studio does not see this environment but will generate a local.properties file with
     * the ndk path set
     */
    if (ndkHome == null) {
        println "Could not locate NDK home in environment variable. Trying local.properties"
        Properties properties = new Properties()
        if (project.rootProject.file('local.properties').exists()) {
            properties.load(project.rootProject.file('local.properties').newDataInputStream())
            ndkHome = properties.getProperty('ndk.dir')
        }
    }

    // Fail the build for no ndk detected
    assert ndkHome != null : "Could not find Android NDK!"

    return ndkHome
}

def getEnvironment() {
    // Possible values for ENVIRONMENT are 'prod', 'stage', and 'dev'.

    // Attempt to get it from the environment variable
    def environment = System.getenv("ENVIRONMENT");

    if (environment == null) {
        println "Could not locate ENVIRONMENT environment variable. Trying local.properties"
        Properties properties = new Properties()
        if (project.rootProject.file('local.properties').exists()) {
            properties.load(project.rootProject.file('local.properties').newDataInputStream())
            environment = properties.getProperty('ENVIRONMENT')
        }
    }

    if (environment == null) {
        println "Could not locate ENVIRONMENT in local.properties."
        environment = "prod"
    }

    println "Environment: " + environment
    return environment;
}

def getPublishConfig() {
    // Possible values for PUBLISH_CONFIG are 'debug' and 'release'.

    // Attempt to get it from the environment variable
    def publishConfig = System.getenv("PUBLISH_CONFIG");

    if (publishConfig == null) {
        println "Could not locate PUBLISH_CONFIG environment variable. Trying local.properties"
        Properties properties = new Properties()
        if (project.rootProject.file('local.properties').exists()) {
            properties.load(project.rootProject.file('local.properties').newDataInputStream())
            publishConfig = properties.getProperty('PUBLISH_CONFIG')
        }
    }

    if (publishConfig == null) {
        println "Could not locate PUBLISH_CONFIG in local.properties."
        publishConfig = "release"
    }

    println "Publish Config: " + publishConfig
    return publishConfig;
}

def getTestCoverageEnabled() {
    def testCoverageEnabled = false

    if (project.hasProperty("testCoverageEnabled")) {
        testCoverageEnabled = project.property("testCoverageEnabled").toBoolean()
    }

    println "Test Coverage Enabled: " + testCoverageEnabled

    return testCoverageEnabled
}

def getTwilioVideoConfig() {
    if (project.file('twilio-video.json').exists()) {
        def slurper = new groovy.json.JsonSlurper()
        def twilioVideoConfig = slurper.parse(project.file('twilio-video.json'));

        // Validate that mandatory credentials are set
        assertCredentialDefined(twilioVideoConfig.credentials, "account_sid");
        assertCredentialDefined(twilioVideoConfig.credentials, "api_key");
        assertCredentialDefined(twilioVideoConfig.credentials, "api_key_secret");

        // Generate credential HashMap
        def hashMapPrefix = "new java.util.HashMap<String , String>() {{\n";
        def hashMapSuffix = "}}";
        def hashMap = hashMapPrefix;

        twilioVideoConfig.credentials.each { credentialsEntry ->
            def hashMapEntry = "    put(\"${credentialsEntry.key}\", \"${credentialsEntry.value}\");\n";
            hashMap += hashMapEntry
        }

        return hashMap + hashMapSuffix;
    } else {
        logger.log(LogLevel.WARN, "Could not find twilio-video.json in " +
                project.projectDir.toString() + ". Library instrumentation tests cannot be run" +
                " without credentials")
    }
}

def assertCredentialDefined(credentials, credentialKey) {
    assert credentials.containsKey(credentialKey) :
            "twilio-video.json must contain key " + credentialKey;
    assert credentials.get(credentialKey) != null : credentialKey + " must not be null";
    assert !credentials.get(credentialKey).equals("") : credentialKey + " must not be empty";
}
